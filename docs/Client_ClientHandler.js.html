<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Client/ClientHandler.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Client/ClientHandler.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Listenable = require("../Utils/Listenable");
const Message = require("../Utils/Message");
const Channel = require("./ChannelHandler");
const WebSocket = require("ws");

class ClientHandler extends Listenable() {

    constructor(url) {
        super();
        if(url.indexOf("://") === -1) url = 'wss://' + url;
        url = url.replace(/^http/, 'ws');
        this.socket = new WebSocket(url);
        this.onopen = () => this.trigger(Message.Types.CONNECT);
        this.onclose = () => this.trigger(Message.Types.DISCONNECT);
        this.onerror = e => console.error(e);
        this.onmessage = e => this._messagehandler(new Message(JSON.parse(e.data)));
        this.channels = [];
        this.id = null;
    }

    _messagehandler(message) {
        if (message.channel === Message.ALL) {
            this.channels.forEach(channel => channel._messagehandler(message));
        }else{
            const channel = this.channel(message.channel);
            if (channel) channel._messagehandler(message);
        }
        this.trigger(message.type, [message.content, message]);
    }

    /**
     * authenticate the socket connection
     * @param userId the user identifier
     * @param token a password or token to authenticate the user
     * @returns Promise resolves when the authentication was successful, fails when it was not successful or after 5 seconds
     * */
    async auth(userId, token) {
        const response = this.request('auth',{id, token});
        if(response === "INVALID") throw new Error(response);
        return response;
    }

    /**
     * joins the channel with the given id
     * @param name the id of the channel, obtainable by calling joinableChannels()
     * */
    async join(name){
        const channel = this.channel(name);
        if(channel) return;
        if("SUCCESS" !== await this.request('join', name)) throw new Error("INVALID");
        this.channels.push(new Channel(name, this));
    }

    /**
     * leaves a channel with the given id
     * @param name the id of a channel to leave. If you are not part of that channel, this will have no effect
     * */
    async leave(name){
        const channel = this.channel(name);
        if(!channel) return;
        if("SUCCESS" !== await this.request('leave', name)) throw new Error("INVALID");
        this.channels = this.channels.filter(c => c.name === name);
    }

    /**
     * creates a new channel and adds it to the joined channels
     * @param name the id of the channel
     * */
    async create(name){
        const channel = this.channel(name);
        if(channel) return;
        if("SUCCESS" !== await this.request('create', name)) throw new Error("INVALID");
        this.channels.push(channel);
    }

    /**
     * @param id the id of the channel
     * @returns Channel the channel with the id or null, if there is no such channel
     * */
    channel(id) {
        const i = this.channels.findIndex(channel => channel.id === id);
        return i >= 0 ? this.channels[i] : null;
    }

    request(type, content, maxtime=5000){
        return new Promise((resolve, reject) => {
            const msg = new Message().withType(type).withContent(content).withSender(this.id).withReceiver(Message.Addresses.SERVER);
            this.send(msg);
            const timeout = setTimeout(() => {
                clearTimeout(timeout);
                reject(new Error("TIMEOUT"));
            }, maxtime);
            const handler = response => {
                if(response.ansered = msg._mid){
                    this.off(type, handler);
                    resolve(response.content);
                }
            };
            this.on(type, handler);
        });
    }

    send(message){
        if(arguments.length === 2){
            message = new Message({
                type: arguments[0],
                content: arguments[1]
            });
        }
        if(!message._sender) message = message.withSender(this.id);
        this.socket.send(JSON.stringify(message));
    }

}

module.exports = ClientHandler;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Channel.html">Channel</a></li><li><a href="ChannelHandler.html">ChannelHandler</a></li><li><a href="Hub.html">Hub</a></li><li><a href="Message.html">Message</a></li><li><a href="ServerContext.html">ServerContext</a></li><li><a href="User.html">User</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Feb 06 2019 19:33:15 GMT+0100 (GMT+01:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
